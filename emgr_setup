#!/usr/bin/env bash

# Copyright 2016-2017 Chris Diamand
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


if [[ -n ${BASH_VERSION+x} ]]; then
    _EMGR_install_dir="${BASH_SOURCE[0]}"
    _EMGR_install_dir=`readlink -f "$_EMGR_install_dir"`
    export _EMGR_install_dir=`dirname "$_EMGR_install_dir"`

    source "$_EMGR_install_dir/setup.bash"
elif [[ -n ${ZSH_VERSION+x} ]]; then
    export _EMGR_install_dir=${0:a:h}

    source "$_EMGR_install_dir/setup.zsh"
fi

function _EMGR_path_for_env() {
    local env="$1" env_dir=
    for env_dir in "${EMGR_DIRS[@]}"; do
        if [[ -d "$env_dir" && -f "$env_dir/$env.env.sh" ]]; then
            echo "$env_dir/$env.env.sh"
            return 0
        fi
    done
    return 1
}

function _EMGR_is_readonly_var() {
    (unset "$1" >&/dev/null) || return 0
    return 1
}

function _EMGR_restore() {
    echo "Restoring from '$_EMGR_env_backup'"
    if [[ -z "$_EMGR_env_backup" || ! -f "$_EMGR_env_backup" ]]; then
        echo "Error: '$_EMGR_env_backup' not set or doesn't exist"
        return 1
    fi

    _EMGR_clear_env
    source "$_EMGR_env_backup"
}

function _EMGR_save() {
    mkdir -p "/tmp/emgr/$USER"
    export _EMGR_env_backup=`mktemp /tmp/emgr/$USER/XXXXXXXX.sh`

    echo "Saving to '$_EMGR_env_backup'"

    echo "# env `date`" > "$_EMGR_env_backup"

    # Call shell-specific env-saving function
    _EMGR_write_env "$_EMGR_env_backup"
}

function _EMGR_load() {
    if [[ -n ${EMGR_ENV_CURRENT+x} ]]; then
        _EMGR_restore
    else
        _EMGR_save
    fi

    export EMGR_ENV_CURRENT="$1"

    source "$_EMGR_install_dir/load_env"
    _EMGR_res="$?"

    if [[ "$_EMGR_res" -ne 0 ]]; then
        echo "Error:" `_EMGR_path_for_env "$EMGR_ENV_CURRENT"` "returned $_EMGR_res"
        _EMGR_clear
    fi
}

function _EMGR_clear() {
    if [[ -z ${EMGR_ENV_CURRENT+x} ]]; then
        echo "Error: No env loaded"
        return 1
    fi
    _EMGR_restore
    rm -f "$_EMGR_env_backup"
    unset _EMGR_env_backup
    unset EMGR_ENV_CURRENT
}

function _EMGR_reload() {
    if [[ -z ${EMGR_ENV_CURRENT+x} ]]; then
        echo "Error: No env loaded"
        return 1
    fi
    echo "Reloading '$EMGR_ENV_CURRENT'"
    _EMGR_load "$EMGR_ENV_CURRENT"
}

function _EMGR_list_envs() {
    local env_dir=
    for env_dir in ${EMGR_DIRS[@]}; do
        if [[ -d "$env_dir" ]]; then
            pushd "$env_dir" >&/dev/null
            find -name '*.env.sh' -printf '  %P\n' | \
                sed 's/\([a-zA-Z0-9]*\)\.env\.sh/\1/'
            popd >&/dev/null
        fi
    done
}

function _EMGR_help() {
    echo "Usage: emgr --clear|--reload|ENV_NAME"
    echo "Available enviroments:"
    _EMGR_list_envs
    return 1
}

function emgr() {
    if [[ $# -lt 1 ]]; then
        _EMGR_help
        return $?
    fi

    if [[ "$1" == "--clear" ]]; then
        _EMGR_clear
    elif [[ "$1" == "--reload" ]]; then
        _EMGR_reload
    else
        _EMGR_load $@
    fi
}

function _EMGR_completion() {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    case "$COMP_CWORD" in
    1)
        COMPREPLY=( $(compgen -W "--clear --reload `_EMGR_list_envs`" -- "$cur") )
        ;;
    esac
}
complete -F _EMGR_completion emgr >&/dev/null
